<h1>ORM needs &amp; Persient</h1>
{%P|old=http://web.archive.org/web/20060112135701/http://mokka.serendipia.net/archives/23-Discussing-OR-requirements-in-light-of-Persient.html|%}
{T|OldStuff|}
<p>Yves Reynhout writes about <a title="What to look for in an O/R mapping tool" href="http://web.archive.org/web/20060112135701/http://weblogs.asp.net/yreynhout/archive/2003/04/18/5796.aspx" >what to look for</a> in an O/R mapping tool..</p>
<p>Now, <a title="www.persient.net" href="http://web.archive.org/web/20060112135701/http://www.persient.net/" >Persient</a> is more a generalized <em>object persistence</em> layer than a relational-database-specific-only <em>mapping</em> tool, but make no mistake, O/R is of course the biggest and (yet) most important part of it.</p>
<p>So I will briefly reflect on Yves' comments and compare and contrast how <a title="Other Persient-related postings" href="http://web.archive.org/web/20060112135701/http://mokka.serendipia.net/categories/19-Persient">Persient Postings</a> would fit in, were you to use his heuristics and stumble across my product in a few months time when it will be ready for prime time.</p>
<p><em>(Note: I quote Yves in the intended block quotes.)</em></p>
{X|h2: Data Source Independence |}
<blockquote><em>Going to different datasources vs. going to one, or switching datasources over time</em></blockquote><p>Supported---the API is completely independent from the underlying permanent storage mechanism being used. You will not be able to use vendor-specific peculiarities, but for the sake of decoupling and portability.</p>
{X|h2: Lazy load, object registry |}
<blockquote><em>Read Patterns of Enterprise Application Architecture for more insight on these (and other) patterns and if they are of any importance to you.  The book is very insightful (but not complete, mind you).</em></blockquote><p>I have not read Martin Fowler's <a title="Patterns of Enterprise Application Architecture" href="http://web.archive.org/web/20060112135701/http://www.martinfowler.com/books.html#eaa" >book</a> but yes, a &quot;registry&quot; of object instances (and their type information as well as parent-child relationships) is kept at permanent storage level.</p>
<p>&quot;Lazy loading&quot; is often presented as some kind of magic that loads a related object automatically on property access. Because Persient is not based on code generation or code injection, but on an object-oriented CRUD API, this does not apply in the same way. <em>Automatic</em> lazy loading on property access is therefore not supported, but the important part, delay loading, is supported---only you do it manually (on property access if you will, although you can optimize stuff much more this way).</p>
<p>This means no (potentially expensive) object caching mechanism is necessary (other than the raw object <em>identity</em> tracking), which means a smaller memory footprint for your application.</p>
{X|h2: &quot;Pluggable&quot; creation mechanism |}
<blockquote><em>How do you want your objects to get created?  Using a base class, reflection, serialization, obligatory interface, pre-compilation code injection, post-compilation code-injection via emission.</em></blockquote><p>Objects are materialized through reflection, no base class inheritance is required. It is &quot;pluggable&quot; in that you can mark any constructor as the &quot;materializer&quot;. If no materializer is specified, a parameter-less constructor (doesn't have to be public) is assumed. Persient is deliberately <em>not</em> based on code injection / generation.</p>
{X|h2: Separation of tiers and layering preferences |}
<blockquote><em>Determine how you want to work with tiers and layers (drawing helps here) and compare how the tool/lib does it.</em></blockquote><p>Persient is built on top of ADO.NET and can be seen as a persistence replacement, so it fits in existing architectures just the same way. Put your data access code whereever you would normally put it---it is just much easier, less code to write, and more intuitive and maintainable (because now it is purely object-oriented).</p>
{X|h2: Transaction control |}
<blockquote><em>To COM+ or to roll &quot;their/your own&quot;. Mainly a choice of technology.</em></blockquote><p>Again, because Persient is a higher-level replacement for ADO.NET, transactions work in a similar way. Call <em>BeginTransaction()</em>, do your object CRUD operations, call <em>Commit()</em> or <em>Rollback()</em>. No declarative stuff and no COM+ integration is required.</p>
{X|h2: Mapping |}
<ul><li><strong>Do you need 1..1 or 1..N or N..M</strong> --- all supported in the same way they are supported, or &quot;doable&quot;, in your average OO language (or more precise, CLR language). Plus, what you don't have explicitly at the language level: parent-child relationships (but these are really only important for deletion operations, a non-issue with transient objects).</li><li><strong>How are collections and dependencies aka associations handled</strong> --- some restrictions apply to collections. No multi-dimensional collections / arrays are supported (yet). Potentially any type can be marked as a collection type, with ArrayList, Hashtable and Array being marked as such by default already. Any type is possible for key and value. They don't have to be strongly typed, but you cannot mix value types and reference types for keys or values in a single collection type (note that each array type is treated as a separate collection type automatically). Collections are normal objects that can be shared by multiple instances, or alternatively, can be the &quot;child&quot; exclusive to another object instance (so it gets deleted when the parent is deleted). In addition to the normal object CRUD operations (<em>Insert</em>, <em>Update</em>, <em>Delete</em>, <em>Load</em>/<em>Select</em>), there is <em>LoadCollection()</em> and <em>UpdateCollection()</em> for the <em>contents</em> of a collection object. A collection object has really two faces, one being a normal object instance (use normal CRUD operations) and one being a container of values or other objects (use the two special collection operations for the <em>contents</em>).</li></ul>
{X|h2: Query facilities |}
<blockquote><em>Write SQL or some OQL like incarnation?</em></blockquote><p>Persient uses OQuery, an object-oriented query language that started out to be an <a title="Original OPath docs" href="http://web.archive.org/web/20060112135701/http://geekswithblogs.net/mokka/archive/2005/05/23/OPath.aspx" >OPath</a> clone but has taken on a life of its own. I will describe it in the near future. See the <a title="Persient Features" href="http://web.archive.org/web/20060112135701/http://mokka.serendipia.net/archives/12-Persient-Features..html" >feature matrix</a> for the core language elements and functions.</p>
<p>Note that CRUD operations are performed using the Persient API, so it's not part of the query language, which unlike SQL is really only about <em>querying</em>, not about data manipulation (DML) or data definition (DDL). So you will not even have to write the ugly, SQLish (and without other CRUD commands completely pointless) SELECT command. Querying objects is as easy as:</p><blockquote><em>Store.Select (typeof (Customer), &quot;<strong>Name.Trim().Like ('p*ttern') or Age &gt; 18</strong>&quot;);</em></blockquote><p >The compilation to SQL is &quot;neato&quot; (and cached)...  =)</p>
{X|h2: Number of DML statements generated |}
<p>Well ... lots of rather smart optimizations have been made and I would dare to state that only as few statements as necessary are ever sent to the data source. Particularly, not only can you delay load stuff (that's standard), but you can also &quot;delay update&quot;: If you only need to update a single property (or two) of an object (or two), you can specify all that granularly and expressively (and object-oriented), and the DML statement will be as compact as hard-coded SQL would be.</p>
{X|h2: Demands from the business layer |}
<p>As much as ADO.NET would demand, as far as CRUD is concerned ...  :)  Regarding the mappings, you currently can use attributes which is nicely declarative but binds your business layer to Persient. If you don't like this, you can do it all imperatively, which means you can have it all in one place and this place can be outside your business layer. A lot of people seem to be fond of messing manually with XML configuration files, so I may decide to include XML support (built on top of the existing imperative facility), maybe even write a plug-in for <a title="Object Mapper" href="http://web.archive.org/web/20060112135701/http://www.matshelander.com/Weblog/DisplayLogEntry.aspx?LogEntryID=75" >ObjectMapper</a> (if it supports plug-ins). Otherwise no demands---no base class or interface requirements. There are optional interfaces for notifications, though.</p>
