<h1>Introducing Persient</h1>
{%P|old=http://web.archive.org/web/20060112142512/http://mokka.serendipia.net/archives/9-Introducing-Persient..html|%}
{T|OldStuff|}
<p>.. an object persistence <em>abstraction</em> layer and &quot;data schema generator&quot; for the .NET Framework.</p>
<p>First off, I originally started this last summer as my <em>final year project</em> (this is the term for a Bachelor's thesis at my <a title="Oxford Brookes University" href="http://www.brookes.ac.uk/">university</a>). What I wanted: a generalized, unified mechanism for transparent, non-redundant persistence of managed objects. </p>
{X|h2: What do I mean by that?|}
<ul><li><strong>Generalized and Unified</strong>&mdash;it does not always have to be an RDBMS. I wanted a simple, efficient, and above all controllable core set of persistence functionality, like <strong>Insert</strong>, <strong>Update</strong>, <strong>Delete</strong>, and <strong>Load</strong> (with object-oriented querying), which could work with an XML data source just as well as with any RDBMS or other <em>structured</em> permanent storage. Plus, I wanted unified, object-oriented support for querying, transactions and cursors.</li><li><strong>Transparent</strong>&mdash;complete control <em>when</em> and <em>how</em> requests are sent to the data source, without having to deal with its implementation details and peculiarities. (This also means: not incurring the often-discussed performance hit of most persistence layers, which maintain costly caches to determine whether object properties have changed.) Furthermore: the ability to accurately represent <em>all</em> (applicable) object-oriented concepts at the permanent storage level <em>AND</em> at the query language level: <strong>polymorphism</strong>, <strong>inheritance</strong>, all kinds of <strong>associations</strong>. No requirement for the objects to implement a base class or set of interfaces.</li><li><strong>Non-redundant</strong>&mdash;most persistence layers require you to do all the object-relational mapping yourself, by manually editing XML configuration files or using a GUI tool. This is fine when you need to access legacy or third-party data schemas, or when you have a DBA / SQL guru around who desparately wants to participate in a project. Otherwise, however, you are left with a solution that enforces great redundancy when designing the information model, which is represented in (1) the object model, (2) the data schema, and (3) the mapping files. To overcome this, you would need to scrap the middle layer and have either end be generated using the information provided by the other end. Code generators are one popular solution: the object-model code is generated from the data schema. However, I was more interested in the other way around: generating the data schema from the object model. There aren't any .NET persistence layers out there for this approach (<strong>or do you know any?</strong>) I like this approach much more, it actually has only one major drawback I can see, and that needs addressing by the Persient project: how to update the data schema from a changed object model without losing existing data (make that object instances).</li></ul>
<p>I worked on Persient for quite a few months part-time, and it progressed well. It is now in this weird state of being already <i>quite stable</i> and <i>quite complete</i>, but still <i>not quite</i>. Suffice it to say, I'm already using it in a commercial, web-based enterprise project (improving it as I go along). So what's next for Persient?</p>
<p>I'm planning to release it as a product, but it needs A LOT more polish, stabilization, optimization, refactoring, and above all documentation, plus some additional features that weren't urgent enough for my purposes yet.</p>
<p>I will soon post:</p>
<ul><li>a revised functional and a technical specification for Persient.</li><li>details about one of my personal features, the <b>OQuery</b> language that is an evolution from Microsoft's <a title="Original Microsoft OPath " href="http://web.archive.org/web/20060112142512/http://www.persient.net/old_ms_opath/">original</a> OPath proposition from the now-abandoned <i>ObjectSpaces</i> project (it really is quite different from OPath now, just like the <em>current</em> OPath language, now part of WinFS, is quite different from this original spec that was my starting point).</li></ul>
